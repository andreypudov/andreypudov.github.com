<?xml version='1.0' encoding='UTF-8' ?>

<!--
 * Official Andrey Pudov website.
 *
 * The MIT License
 *
 * Copyright 2011-2015 Andrey Pudov.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
-->

<!--
    Document   : xml-parser-in-c.html
    Created on : Jan 25, 2015, 02:30:00 PM
    Author     : Andrey Pudov        <mail@andreypudov.com>
    Description:
        The content web page.
-->
<!DOCTYPE html>
<html>
    <body>
      <define name='title'>
        <title>Andrey Pudov - XML Parser in C</title>
      </define>
      
      <define name='content'>
        <div class='container'>
          <div class='page-header'>
            <h1>XML Parser in C<small><em>Friday, July 27, 2012</em></small></h1>
          </div>

          <p>The project started last year was required to the develop an XML parser with basic functionality as a part of large library that using XML as standard for all input/ouput configuration and data files. In case of stringent requirements to use only an ANSI C and no external libraries, I decided to develop the parser by myself.</p>

          <p>This post is describe how it work - the XML parser loads an XML file in memory, parses the file and generates a tree structure representing the XML content.  Of course, you can also parse XML data that you have already stored yourself into a memory buffer. Thereafter, you can easily going through the tree to work with data and modify it by adding new elements or removing existing. XML tree designed to minimize memory usage and simplify corresponding algorithms, that, unfortunately, made  memory management a little complicated.</p>

          <p>Top element in the tree is 'Parent', that links to the top of children elements stored in linked list, where last element is Null pointer. In this structure is very easy to traverse through element's tree by hand without using additional DOM or SAX parsers.</p>
          
          <img src="../images/pages/PAGE_XML_Parser.jpg" class="img-responsive">

          <p>Corresponding code look as follows:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#00f;font-weight:700">typedef</span> <span style="color:#00f;font-weight:700">struct</span> _XMLDocument  XMLDocument;
<span style="color:#00f;font-weight:700">typedef</span> <span style="color:#00f;font-weight:700">struct</span> _XMLElement   XMLElement;
<span style="color:#00f;font-weight:700">typedef</span> <span style="color:#00f;font-weight:700">struct</span> _XMLAttribute XMLAttribute;

<span style="color:#00f;font-weight:700">struct</span> _XMLDocument {
    XMLElement *elements;
};

<span style="color:#00f;font-weight:700">struct</span> _XMLElement {
    wchar_t *name;
    wchar_t *value;
    
    XMLAttribute *attributes;
   
    /* the link to the parent element in the list */ 
    XMLElement *parent;
    /* the link to the next child element in the list */
    XMLElement *elements;
   
    /* the link to the next element in the list */ 
    XMLElement *next;
};

<span style="color:#00f;font-weight:700">struct</span> _XMLAttribute {
    wchar_t *name;
    wchar_t *value;

    /* the linke to the next element in the list */
    XMLAttribute *next;
};
          </pre>

          <p>The code reads an XML file is placed in separate file and implemented as loop that going through the XML file content and reads next character on each subsequent iteration. At the beginning XML reader initializes variable values and determines the length of provided XML file.</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#00f;font-weight:700">const</span> <span style="color:#6d79de;font-weight:700">size_t</span>  STRING_LENGTH = <span style="color:#0000cd">256</span>;
    <span style="color:#00f;font-weight:700">const</span> wchar_t *EMPTY_STRING = L<span style="color:#036a07">""</span>;

    XMLDocument  *document  = installer_xml_document_new();
    XMLAttribute *attribute = <span style="color:#585cf6;font-weight:700">NULL</span>;
    XMLElement   *element   = <span style="color:#585cf6;font-weight:700">NULL</span>;
        XMLElement   *element_t = <span style="color:#585cf6;font-weight:700">NULL</span>;     <span style="color:#06f;font-style:italic">/* temporaary element */</span>

    <span style="color:#06f;font-style:italic">/* xml string to parse */</span>
    wchar_t *string         = <span style="color:#585cf6;font-weight:700">NULL</span>;

    <span style="color:#00f;font-weight:700">int</span>     index           = <span style="color:#0000cd">0</span>;        <span style="color:#06f;font-style:italic">/* first level cursor */</span>
    wchar_t character       = WEOF;
    wchar_t delim           = WEOF;
    <span style="color:#00f;font-weight:700">bool</span>    inside_flag     = <span style="color:#585cf6;font-weight:700">false</span>;

    wchar_t *element_name   = (wchar_t*) calloc(STRING_LENGTH, <span style="color:#00f;font-weight:700">sizeof</span>(wchar_t));
    wchar_t *element_value  = (wchar_t*) calloc(STRING_LENGTH, <span style="color:#00f;font-weight:700">sizeof</span>(wchar_t));
    wchar_t *attribute_name = (wchar_t*) calloc(STRING_LENGTH, <span style="color:#00f;font-weight:700">sizeof</span>(wchar_t));
    wchar_t *attribute_value= (wchar_t*) calloc(STRING_LENGTH, <span style="color:#00f;font-weight:700">sizeof</span>(wchar_t));

    <span style="color:#00f;font-weight:700">long</span> file_length        = <span style="color:#0000cd">0</span>;        <span style="color:#06f;font-style:italic">/* file length */</span>
    <span style="color:#00f;font-weight:700">long</span> character_number   = <span style="color:#0000cd">0</span>;        <span style="color:#06f;font-style:italic">/* how much characters in file */</span>
                                        <span style="color:#06f;font-style:italic">/* character_numner &lt;= file_length */</span>

    <span style="color:#06f;font-style:italic">/* function argument and variables are can't be NULL */</span>
    <span style="color:#00f;font-weight:700">if</span> ((reader == <span style="color:#585cf6;font-weight:700">NULL</span>) || (document == <span style="color:#585cf6;font-weight:700">NULL</span>)
            || (element_name == <span style="color:#585cf6;font-weight:700">NULL</span>) || (element_value == <span style="color:#585cf6;font-weight:700">NULL</span>)
            || (attribute_name == <span style="color:#585cf6;font-weight:700">NULL</span>) || (attribute_value == <span style="color:#585cf6;font-weight:700">NULL</span>)) {
        free(document);

        return NULL;
    }

    <span style="color:#06f;font-style:italic">/* determines length of the xml file and reads this file into buffer */</span>
    <span style="color:#0000a2;font-weight:700">fseek</span>(reader->pointer, 0L, SEEK_END);
    file_length = ftell(reader->pointer);
    <span style="color:#0000a2;font-weight:700">fseek</span>(reader->pointer, 0L, SEEK_SET);
    string = (wchar_t*) calloc(file_length + <span style="color:#0000cd">1</span>, <span style="color:#00f;font-weight:700">sizeof</span>(wchar_t));

    <span style="color:#06f;font-style:italic">/* file is empty */</span>
    <span style="color:#00f;font-weight:700">if</span> ((file_length &lt;= <span style="color:#0000cd">0</span>) || (string == <span style="color:#585cf6;font-weight:700">NULL</span>)) {
        return NULL;
    }

    <span style="color:#06f;font-style:italic">/* add first element to the document */</span>
    element_t = installer_xml_element_new(L<span style="color:#036a07">"XML DOCUMENT"</span>, L<span style="color:#036a07">"v1.0"</span>);
    element   = installer_xml_document_add_element(document, element_t);
    <span style="color:#0000a2;font-weight:700">installer_xml_element_delete</span>(element_t);

    element_t = installer_xml_element_new(EMPTY_STRING, EMPTY_STRING);
    element   = installer_xml_element_add_element(element, element_t);
    <span style="color:#0000a2;font-weight:700">installer_xml_element_delete</span>(element_t);

    <span style="color:#06f;font-style:italic">/* fread(string, sizeof(wchar_t), 30, reader->pointer); */</span>
    character   = fgetwc(reader->pointer); <span style="color:#06f;font-style:italic">/* leave start point */</span>
    <span style="color:#00f;font-weight:700">while</span> (((character = fgetwc(reader->pointer)) != WEOF)) {
        string[character_number] = character;
        character_number++;
    }
          </pre>

          <p>The process of parsing XML content is implemented in the body of while loop where current content character is compares to XML tokens (for example, '<' and '>' symbols or sequence of symbols like '!--'). To simplify parsing algorithm I wrote external functions, like 'append_character' that append specified character to the existing string. There is also required to have an access to string elements located before and after current character, - and it's not a problem in this design by obtaining that values from allocated string.</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/* main parser loop */</span>
    <span style="color:#00f;font-weight:700">while</span> (index &lt; character_number) {
        character = string[index];

        if ((character == NEW) || (character == TAB) || (character == RET)) {
            index++;

            continue;
        }

        if (character == OPEN) {
            /* comment section */
            if ((string[index + 1] == EXCLAMATION)
                    &amp;&amp; (string[index + 2] == MINUS)
                    &amp;&amp; (string[index + 3] == MINUS)) {
                memset(attribute_value, 0, STRING_LENGTH * sizeof(wchar_t));
                index += 4;
                character = string[index];

                while (!((string[index] == MINUS)
                        &amp;&amp; (string[index + 1] == MINUS)
                        &amp;&amp; (string[index + 2] == CLOSE))) {
                    _installer_xml_reader_append_character(attribute_name,
                                                           character);
                    character = string[++index];
                }

                index += 3;

                /* 
                 * comments will not be added to xml structure 
                 */
                
                continue;
            }

            /* closing tag for the last opened element */
            memset(element_name, 0, STRING_LENGTH * sizeof(wchar_t));
            if (string[index + 1] == SLASH) {
                /* element = element->parent */
                element = installer_xml_element_get_parent(element);
                index++;

                while (string[index] != CLOSE) {
                    index++;
                }

                index++;

                continue;
            }

            if (string[index + 1] == QM) {
                character = string[++index];
                inside_flag = true;
            }

            /* create a new element */
            character = string[++index];
            while ((character != SLASH)
                    &amp;&amp; (character != SPACE)
                    &amp;&amp; (character != CLOSE)) {
                /* going until the element name has been entirely read */
                if ((character != NEW)
                        &amp;&amp; (character != TAB)
                        &amp;&amp; (character != RET)) {
                    _installer_xml_reader_append_character(element_name,
                                                           character);
                }

                character = string[++index];
            }

                        /* element has been seted, going to the child element */
            if (<span style="color:#3c4c72;font-weight:700">wcscmp</span>(<span style="color:#0000a2;font-weight:700">installer_xml_element_get_name</span>(element), EMPTY_STRING) != 0) {
                                /* element = element->child */
                                element_t = installer_xml_element_new(EMPTY_STRING, EMPTY_STRING);
                                element   = installer_xml_element_add_element(element, element_t);

                                installer_xml_element_delete(element_t);
            }

            /* element->name = element_name */
            installer_xml_element_set_name(element, element_name);
            while (character == SPACE) {
                character = string[++index];

                if (character == SLASH) {
                    break;
                }

                if ((character == QM) &amp;&amp; (inside_flag == true)) {
                    break;
                }

                memset(attribute_name,  0, STRING_LENGTH * sizeof(wchar_t));
                memset(attribute_value, 0, STRING_LENGTH * sizeof(wchar_t));
                /* going until the attribute name has been entirely read */
                while (character != EQUAL) {
                    if ((character != NEW)
                            &amp;&amp; (character != TAB)
                            &amp;&amp; (character != RET)) {
                        _installer_xml_reader_append_character(attribute_name,
                                                               character);
                    }

                    character = string[++index];
                }

                character = string[++index];
                if ((character == QUOTE) || (character == DQUOTE)) {
                    delim     = character;
                    character = string[++index];
                }

                /* going until the attribute value has been entirely read */
                while ((character != delim) &amp;&amp; (delim != WEOF)) {
                    if ((character != NEW)
                            &amp;&amp; (character != TAB)
                            &amp;&amp; (character != RET)) {
                        _installer_xml_reader_append_character(attribute_value,
                                                               character);
                    }

                    character = string[++index];
                }

                delim     = WEOF;
                character = string[++index];
                attribute = installer_xml_attribute_new(attribute_name,
                                                        attribute_value);

                installer_xml_element_add_attribute(element, attribute);
                                installer_xml_attribute_delete(attribute);
            }

            if (character == SLASH) {
                /* element = element->parent */
                element = installer_xml_element_get_parent(element);

                character = string[++index];

                while (character != CLOSE) {
                    character = string[++index];
                }
            }

            /* first xml element end &lt;?xml version="1.0" encoding="UTF-8"?> */
            if ((character == QM) &amp;&amp; (inside_flag == true)) {
                /* element = element->parent - parent is NULL for the first element */
                element = installer_xml_element_get_parent(element);

                character   = string[++index];
                inside_flag = false;

                while (character != CLOSE) {
                    character = string[++index];
                }
            }
        }

        /* element has a value */
        if ((character != OPEN)
                &amp;&amp; (character != CLOSE)
                &amp;&amp; (character != SLASH)
                &amp;&amp; (character != SPACE)) {
            memset(element_value,  0, STRING_LENGTH * sizeof(wchar_t));

            while (character != OPEN) {
                if ((character != NEW)
                        &amp;&amp; (character != TAB)
                        &amp;&amp; (character != RET)) {
                    _installer_xml_reader_append_character(element_value,
                                                           character);
                }

                character = string[++index];
            }

            /* element->value = element_value */
            installer_xml_element_set_value(element, element_value);

            continue;
        }

        index++;
    }
</pre>
         <p>The illustrated code does not meet the XML standard in its entirety, but it can be used to parse well-formatted XML data in non-critical part of your application. It's small, fast, and can be ported to any platform. You can obtain source code under MIT license from project website - <a href='http://code.google.com/p/installer-core/'>http://code.google.com/p/installer-core/</a>.</p>

          <p><a href='p/xml-parser-in-c-usage-and-examples.html'>XML Parser in C - Usage and Examples</a></p>
        </div>
      </define>
    </body>
</html>
