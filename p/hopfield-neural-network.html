<!--
 * Andrey Pudov Official Website
 *
 * The MIT License
 *
 * Copyright 2011-2016 Andrey Pudov.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Andrey Pudov - Hopfield Neural Network</title>
    
    <meta charset='utf-8' />
    <meta http-equiv='X-UA-Compatible' content='IE=edge' />
    
    <meta name='viewport'    content='width=device-width, initial-scale=1.0' />
    <meta name='description' content='Official Andrey Pudov website featuring Andrey Pudov news, photo albums and more.' />
    <meta name='author'      content='Andrey Pudov' />
    
    <!-- bootstrap core style sheet -->
    <link href='../libraries/bootstrap/css/bootstrap.css' rel='stylesheet' />

    <link rel='apple-touch-icon' sizes='180x180' href='../images/favicon/apple-touch-icon.png'>
    <link rel='icon' type='image/png' sizes='32x32' href='../images/favicon/favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='16x16' href='../images/favicon/favicon-16x16.png'>
    <link rel='manifest' href='../images/favicon/site.webmanifest'>

    <!-- web page specific styles declaration -->
    
    
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src='https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js'></script>
      <script src='https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js'></script>
    <![endif]-->

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-74198577-1', 'auto');
      ga('send', 'pageview');

    </script>
    <!-- /Google Analytics -->
  </head>
    <body>
      <div id='page'>
        <div id='header'>
          <div class='navbar-wrapper'>
    <div class='container'>
        <div class='navbar navbar-static-top' role='navigation'>
            <div class='container'>
                <div class='navbar-header'>
                    <button type='button' class='navbar-toggle' data-toggle='collapse' data-target='.navbar-collapse'>
                        <span class='sr-only'>Toggle navigation</span>
                        <span class='icon-bar'></span>
                        <span class='icon-bar'></span>
                        <span class='icon-bar'></span>
                    </button>
                    <a href='../index.html' class='navbar-brand'>Andrey Pudov</a>
                </div>
                <div class='navbar-collapse collapse'>
                    <ul class='nav navbar-nav'>
                        <li class='active'><a href='../albums.html'>Albums</a></li>
	                    <li><a href='../contents.html'>Contents</a></li>
	                    <li><a href='../resume.html'>Resume</a></li>
	                    <li><a href='../contact.html'>Contact</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>

        </div>
        <div id='content'>
          <div class='container'>
          <div class='page-header'>
            <h1>Hopfield Neural Network<small><em>Sunday, April 17, 2011</em></small></h1>
          </div>

          <p>Hopfield neural network - is a form of recurrent artificial neural network, was first introduced by American scientist John Hopfield in 1982. This was the starting point of the new era of neural networks, which continues today.</p>

          <p>Hopfield showed that models of physical systems could be used to solve computational problems. Such systems could be implemented in hardware by combining standard components such as capacitors and resistors. Application is limited due to theoretical limitations of the network structure but, in certain situations, they may form interesting models. Network can be used as associative memory, filter, or in solving optimization problems; typically used in classification problems, where the original image is converted into binary number vector.</p>

          <h2>Network architecture</h2>

          <p>The units in <a href='http://en.wikipedia.org/wiki/Hopfield_net'>Hopfield nets</a> are binary threshold units, i.e. the units only take on two different values for their states and the value is determined by whether or not the units' input exceeds their threshold. Hopfield nets can either have units that take on values of 1 or -1, or units that take on values of 1 or 0. So, the two possible definitions for unit i's activation, ai, are:</p>

          <img src="../images/pages/PAGE_Hopfield_Equation_1.png" class="img-responsive">

          <img src="../images/pages/PAGE_Hopfield_Equation_2.png" class="img-responsive">

          <p>Where:</p>

          <ul>
            <li>w<sub>ij</sub> is the strength of the connection weight from unit j to unit i (the weight of the connection).</li>
            <li>s<sub>j</sub> is the state of unit j.</li>
            <li>Î¸<sub>i</sub> is the threshold of unit i. </li>
          </ul>

          <p>The connections in a Hopfield net typically have the following restrictions:</p>

          <img src="../images/pages/PAGE_Hopfield_Equation_3.png" class="img-responsive">
          <small>(no unit has a connection with itself)</small><br />

          <img src="../images/pages/PAGE_Hopfield_Equation_4.png" class="img-responsive">
          <small>(connections are symmetric)</small>

          <p>The requirement that weights be symmetric is typically used, as it will guarantee that the <a href='http://en.wikipedia.org/wiki/Optimization_%28mathematics%29'>energy function</a> decreases monotonically while following the activation rules, and the network may exhibit some periodic or chaotic behavior if non-symmetric weights are used. However, Hopfield found that this chaotic behavior is confined to relatively small parts of the phase space, and does not impair the network's ability to act as a content-addressable associative memory system.</p>

          <p>Hopfield nets have a scalar value associated with each state of the network referred to as the "energy", E, of the network, where:</p>

          <img src="../images/pages/PAGE_Hopfield_Equation_5.png" class="img-responsive">

          <p>This value is called the "energy" because the definition ensures that if units are randomly chosen to update their activations the network will converge to states which are local minima in the energy function (which is considered to be a Lyapunov function). Thus, if a state is a local minimum in the energy function it is a stable state for the network. Note that this energy function belongs to a general class of models in physics, under the name of Ising models; these in turn are a special case of Markov networks, since the associated probability measure, the Gibbs measure, has the Markov property.</p>

          <h2>Constructing the Hopfield Network</h2>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/**
 * This is an example that implements a Hopfield neural network. This example
 * network contains four fully connected neurons.
 *
 * <span style="color:#00f;font-weight:700">@version</span> 0.00 15 Apr 2011
 * <span style="color:#00f;font-weight:700">@author</span>  Andrey Pudov  
 */</span>
<span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">class</span> <span style="text-decoration:underline">Hopfield</span> {
    <span style="color:#06f;font-style:italic">/**
     * The number of neurons in this neural network.
     */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">final</span> <span style="color:#00f;font-weight:700">int</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>;
   
    <span style="color:#06f;font-style:italic">/**
    * The weight matrix for the fully connected neurons.
    */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">int</span>[][] matrix;
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#0000a2;font-weight:700">Hopfield</span>(<span style="color:#00f;font-weight:700">int</span> <span style="font-style:italic">size</span>) {
    <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span> <span style="color:#00f;font-weight:700">=</span> size;
    matrix       <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>][<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>];
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
            <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> col <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; col <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>col) {
                matrix[row][col] <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>;
            }
        }
    }
    <span style="color:#06f;font-style:italic">/**
     * Called when the neural network is to be ran against the input.
     */</span>
    <span style="color:#00f;font-weight:700">protected</span> <span style="color:#00f;font-weight:700">int</span>[] <span style="color:#0000a2;font-weight:700">recognize</span>(<span style="color:#00f;font-weight:700">int</span>[] <span style="font-style:italic">input</span>) {
        <span style="color:#00f;font-weight:700">boolean</span>[] pattern <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">boolean</span>[<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>];
        <span style="color:#00f;font-weight:700">int</span>[]     output  <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>];
       
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
            <span style="color:#00f;font-weight:700">int</span> i <span style="color:#00f;font-weight:700">=</span> input[row];
           
            <span style="color:#00f;font-weight:700">if</span> (i <span style="color:#00f;font-weight:700">==</span> <span style="color:#0000cd">0</span>) {
                pattern[row] <span style="color:#00f;font-weight:700">=</span> <span style="color:#585cf6;font-weight:700">false</span>;
            } <span style="color:#00f;font-weight:700">else</span> {
                pattern[row] <span style="color:#00f;font-weight:700">=</span> <span style="color:#585cf6;font-weight:700">true</span>;
            }
        }
       
        <span style="color:#00f;font-weight:700">Layer</span> net <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">Layer</span>(matrix);
        net<span style="color:#00f;font-weight:700">.</span>activation(pattern);
        <span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>;
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">boolean</span> i <span style="color:#00f;font-weight:700">:</span> net<span style="color:#00f;font-weight:700">.</span>getOutput()) {
            <span style="color:#00f;font-weight:700">if</span> (i) {
                output[row<span style="color:#00f;font-weight:700">++</span>] <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">1</span>;
            } <span style="color:#00f;font-weight:700">else</span> {
                output[row<span style="color:#00f;font-weight:700">++</span>] <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>;
            }
        }
        <span style="color:#00f;font-weight:700">return</span> output;
    }
    <span style="color:#06f;font-style:italic">/**
     * Called to clear the weight matrix.
     */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">void</span> <span style="color:#0000a2;font-weight:700">clear</span>() {
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
            <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> col <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; col <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>col) {
                matrix[row][col] <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>;
            }
        }
    }
    <span style="color:#06f;font-style:italic">/**
     * Called to train the weight matrix based on the
     * current input pattern.
     */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">void</span> <span style="color:#0000a2;font-weight:700">train</span>(<span style="color:#00f;font-weight:700">int</span>[] <span style="font-style:italic">input</span>) {
        <span style="color:#00f;font-weight:700">int</span>[][] work <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>][<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>];
        <span style="color:#00f;font-weight:700">int</span>[]   bi   <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[<span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>];
       
        <span style="color:#06f;font-style:italic">/* convert to bipolar (0 = -1, 1 = 1) */</span>
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> x <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; x <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>x) {
            <span style="color:#00f;font-weight:700">if</span> (input[x] <span style="color:#00f;font-weight:700">==</span> <span style="color:#0000cd">0</span>) {
                bi[x] <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">-</span><span style="color:#0000cd">1</span>;
            } <span style="color:#00f;font-weight:700">else</span> {
                bi[x] <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">1</span>;
            }
        }
      <span style="color:#06f;font-style:italic">/* multiply the matrix by its transposition */</span>      
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
            <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> col <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; col <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>col) {
                work[row][col] <span style="color:#00f;font-weight:700">=</span> bi[row] <span style="color:#00f;font-weight:700">*</span> bi[col];
            }
        }
       
      <span style="color:#06f;font-style:italic">/* set the northwest diagonal to -1 */</span>
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> x <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; x <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>x) {
            work[x][x] <span style="color:#00f;font-weight:700">-=</span> <span style="color:#0000cd">1</span>;
        }
       
      <span style="color:#06f;font-style:italic">/* add to the existing weight matrix */</span>
        <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
            <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> col <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; col <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>col) {
                <span style="color:#00f;font-weight:700">int</span> i <span style="color:#00f;font-weight:700">=</span> matrix[row][col];
               
                matrix[row][col] <span style="color:#00f;font-weight:700">=</span> (i <span style="color:#00f;font-weight:700">+</span> work[row][col]);
            }
        }
    }
}
</pre>

          <h2>Training the Network</h2>

          <p>The train method is responsible for adjusting the weight matrix so that the new pattern can be correctly recalled. This process takes several steps. You will now be shown how the network trains.</p>

          <p>Training a Hopfield Network involves lowering the energy of states that the net should "remember". This allows the net to serve as a content addressable memory system, that is to say, the network will converge to a "remembered" state if it is given only part of the state. The net can be used to recover from a distorted input the trained state that is most similar to that input. This is called associative memory because it recovers memories on the basis of similarity. For example, if we train a Hopfield net with five units so that the state (1, 0, 1, 0, 1) is an energy minimum, and we give the network the state (1, 0, 0, 0, 1) it will converge to (1, 0, 1, 0, 1). Thus, the network is properly trained when the energy of states which the network should remember are local minima.</p>

          <p>As the input is retrieve the values are converted to bipolar values. Conversion to bipolar simply involves converting every 0 to a â1 of a binary number; the output is stored in the bi array. This is done as follows:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/* convert to bipolar (0 = -1, 1 = 1) */</span>
<span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> x <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; x <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>x) {
    <span style="color:#00f;font-weight:700">if</span> (input[x] <span style="color:#00f;font-weight:700">==</span> <span style="color:#0000cd">0</span>) {
        bi[x] <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">-</span><span style="color:#0000cd">1</span>;
    } <span style="color:#00f;font-weight:700">else</span> {
        bi[x] <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">1</span>;
    }
}
</pre>

          <p>The next step is to multiply the input sequence by its transposition. To perform this operation a new matrix is constructed, called work, that is perfectly square. Its width is determined by the width of the input sequence. Here each element of the work matrix is filled with a value that is derived by multiplying the value of the input sequence that contains the same row and column. This is done with the following code:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/* multiply the matrix by its transposition */</span>      
<span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
    <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> col <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; col <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>col) {
        work[row][col] <span style="color:#00f;font-weight:700">=</span> bi[row] <span style="color:#00f;font-weight:700">*</span> bi[col];
    }
}
</pre>

          <p>A Hopfield Neural network does not generally assign weights between the same neurons. For example, there would be no weight between neuron 0 and itself. The weight of each neuron back to itself must be set to â1 (0 in bipolar). This is done with the following code:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/* set the northwest diagonal to -1 */</span>
<span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> x <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; x <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>x) {
    work[x][x] <span style="color:#00f;font-weight:700">-=</span> <span style="color:#0000cd">1</span>;
}
</pre>

          <p>Finally the work matrix must be added to the existing weight matrix. This is done by taking each element of the work matrix and adding it to the corresponding element of the actual weight matrix.</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/* add to the existing weight matrix */</span>
<span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> row <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; row <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>row) {
    <span style="color:#00f;font-weight:700">for</span> (<span style="color:#00f;font-weight:700">int</span> col <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>; col <span style="color:#00f;font-weight:700">&lt;</span> <span style="color:#c5060b;font-weight:700">NETWORK_SIZE</span>; <span style="color:#00f;font-weight:700">++</span>col) {
        <span style="color:#00f;font-weight:700">int</span> i <span style="color:#00f;font-weight:700">=</span> matrix[row][col];
               
        matrix[row][col] <span style="color:#00f;font-weight:700">=</span> (i <span style="color:#00f;font-weight:700">+</span> work[row][col]);
    }
}
</pre>

          <h2>Network operation</h2>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/**
 * <span style="color:#00f;font-weight:700">@version</span> 0.00 15 Apr 2011
 * <span style="color:#00f;font-weight:700">@author</span> Andrey Pudov
 */</span>
<span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">class</span> <span style="text-decoration:underline">Layer</span>{
   <span style="color:#06f;font-style:italic">/**
    * An array of neurons.
    */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">Neuron</span>[] neurons;
   <span style="color:#06f;font-style:italic">/**
    * The output of the neurons.
    */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">boolean</span>[] output;
   <span style="color:#06f;font-style:italic">/**
    * The number of neurons in this layer. And because this is a
    * single layer neural network, this is also the number of
    * neurons in the network.
    */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">int</span> size;
   <span style="color:#06f;font-style:italic">/**
    * A constant to multiply against the threshold function.
    * This is not used, and is set to 1.
    */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">static</span> <span style="color:#00f;font-weight:700">final</span> <span style="color:#00f;font-weight:700">double</span> lambda<span style="color:#00f;font-weight:700">=</span><span style="color:#0000cd">1.0</span>;
   <span style="color:#06f;font-style:italic">/**
    * The constructor. The weight matrix for the neurons must be passed in.
    * Because this is a single layer network the weight array should always be
    * perfectly square(i.e. 4x4). These weights are used to initialize the
    * neurons.
    *
    * <span style="color:#00f;font-weight:700">@param</span> weights A 2d array that contains the weights between each
    *        neuron and the other neurons
    */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#0000a2;font-weight:700">Layer</span>(<span style="color:#00f;font-weight:700">int[][]</span><span style="font-style:italic">weights</span>){  
        size <span style="color:#00f;font-weight:700">=</span> weights[<span style="color:#0000cd">0</span>]<span style="color:#00f;font-weight:700">.</span>length;
   
        neurons <span style="color:#00f;font-weight:700">=</span> newNeuron[size];
        output  <span style="color:#00f;font-weight:700">=</span> newboolean[size];
   
        <span style="color:#00f;font-weight:700">for</span>(<span style="color:#00f;font-weight:700">int</span> i<span style="color:#00f;font-weight:700">=</span><span style="color:#0000cd">0</span>;i<span style="color:#00f;font-weight:700">&lt;</span>size;i<span style="color:#00f;font-weight:700">++</span>){
            neurons[i] <span style="color:#00f;font-weight:700">=</span> newNeuron(weights[i]);
        }
    }
   <span style="color:#06f;font-style:italic">/**
    * The threshold method is used to determine if the neural
    * network will fire for a given pattern. This threshold
    * uses the hyperbolic tangent (tanh).
    *
    * <span style="color:#00f;font-weight:700">@param</span> k The product of the neuron weights and the input pattern.
    * <span style="color:#00f;font-weight:700">@return</span> Whether to fire or not to fire.
    */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">boolean</span> <span style="color:#0000a2;font-weight:700">threshold</span>(<span style="color:#00f;font-weight:700">int</span> <span style="font-style:italic">k</span>){
   
        <span style="color:#00f;font-weight:700">return</span>(<span style="color:#00f;font-weight:700">StrictMath</span><span style="color:#00f;font-weight:700">.</span>tanh(k) <span style="color:#00f;font-weight:700">>=</span> <span style="color:#0000cd">0</span>);
    }
   <span style="color:#06f;font-style:italic">/**
    * This method is called to actually run the neural network.
    *
    * <span style="color:#00f;font-weight:700">@param</span> pattern The input pattern to present to the neural network.
    */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">void</span> <span style="color:#0000a2;font-weight:700">activation</span>(<span style="color:#00f;font-weight:700">boolean[]</span><span style="font-style:italic">pattern</span>){
        <span style="color:#00f;font-weight:700">int</span> i,j;
   
        <span style="color:#00f;font-weight:700">for</span>(i<span style="color:#00f;font-weight:700">=</span><span style="color:#0000cd">0</span>;i<span style="color:#00f;font-weight:700">&lt;</span>size;<span style="color:#00f;font-weight:700">++</span>i){
            neurons[i]<span style="color:#00f;font-weight:700">.</span>setActivation(neurons[i]<span style="color:#00f;font-weight:700">.</span>act(pattern));
            output[i] <span style="color:#00f;font-weight:700">=</span> threshold(neurons[i]<span style="color:#00f;font-weight:700">.</span>getActivation());
        }
    }
    <span style="color:#00f;font-weight:700">public</span> boolean[]<span style="color:#0000a2;font-weight:700">getOutput</span>(){
        <span style="color:#00f;font-weight:700">return</span> output;
    }
}
</pre>

          <p>When the constructor is called for the Layer class, the weight matrix is passed in. This will allow the Layer class to determine what the output should be for a given input pattern. To determine the output sequence, an input sequence should be passed to the activation method of the Layer class. The activation method calls the each of the neurons to determine their output. The following code does this:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#00f;font-weight:700">for</span>(i<span style="color:#00f;font-weight:700">=</span><span style="color:#0000cd">0</span>; i <span style="color:#00f;font-weight:700">&lt;</span> size; <span style="color:#00f;font-weight:700">++</span>i){
    neurons[i]<span style="color:#00f;font-weight:700">.</span>setActivation(neurons[i]<span style="color:#00f;font-weight:700">.</span>act(pattern));
    output[i] <span style="color:#00f;font-weight:700">=</span> threshold(neurons[i]<span style="color:#00f;font-weight:700">.</span>getActivation());
}
</pre>

          <p>The above loop stores each neuronâs activation value in the same neuron. Each activation is determined by calling the act method of the Neuron. To see how each neuron calculates its activation we must first examine the Neuron class:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#06f;font-style:italic">/**
 * <span style="color:#00f;font-weight:700">@version</span> 0.00 15 Apr 2011
 * <span style="color:#00f;font-weight:700">@author</span> Andrey Pudov
 */</span>
<span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">class</span> <span style="text-decoration:underline">Neuron</span> {
    <span style="color:#06f;font-style:italic">/**
     * The weights between this neuron and the other neurons on
     * the layer.
     */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">int</span>[] weightv;
    <span style="color:#06f;font-style:italic">/**
     * Activation results for this neuron.
     */</span>
    <span style="color:#00f;font-weight:700">private</span> <span style="color:#00f;font-weight:700">int</span> activation;
    <span style="color:#06f;font-style:italic">/**
     * The constructor. The weights between this neuron and
     * every other neuron(including itself) is passed in as
     * an array. Usually the weight between this neuron and
     * itself is zero.
     *
     * <span style="color:#00f;font-weight:700">@param</span> in The weight vector.
     */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#0000a2;font-weight:700">Neuron</span>(<span style="color:#00f;font-weight:700">int[]</span><span style="font-style:italic">in</span>){
        weightv <span style="color:#00f;font-weight:700">=</span> in;
    }
    <span style="color:#06f;font-style:italic">/**
     * This method is called to determine if the neuron would
     * activate, or fire.
     *
     * <span style="color:#00f;font-weight:700">@param</span> x Neuron input
     * <span style="color:#00f;font-weight:700">@return</span> If the neuron would activate, or fire
     */</span>
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">int</span> <span style="color:#0000a2;font-weight:700">act</span>(<span style="color:#00f;font-weight:700">boolean[]</span><span style="font-style:italic">x</span>){
        <span style="color:#00f;font-weight:700">int</span> i;
        <span style="color:#00f;font-weight:700">int</span> a <span style="color:#00f;font-weight:700">=</span> <span style="color:#0000cd">0</span>;
   
        <span style="color:#00f;font-weight:700">for</span>(i<span style="color:#00f;font-weight:700">=</span><span style="color:#0000cd">0</span>; i<span style="color:#00f;font-weight:700">&lt;</span>x<span style="color:#00f;font-weight:700">.</span>length; i<span style="color:#00f;font-weight:700">++</span>){
            <span style="color:#00f;font-weight:700">if</span>(x[i]){
                a <span style="color:#00f;font-weight:700">+=</span> weightv[i];
            }
        }
   
        <span style="color:#00f;font-weight:700">return</span> a;
    }
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">int</span> <span style="color:#0000a2;font-weight:700">getActivation</span>(){
        <span style="color:#00f;font-weight:700">return</span> activation;
    }
    <span style="color:#00f;font-weight:700">public</span> <span style="color:#00f;font-weight:700">void</span> <span style="color:#0000a2;font-weight:700">setActivation</span>(<span style="color:#00f;font-weight:700">int</span> <span style="font-style:italic">activation</span>){
        <span style="color:#318495">this</span><span style="color:#00f;font-weight:700">.</span>activation <span style="color:#00f;font-weight:700">=</span> activation;
    }
}
</pre>

          <p>To calculate a neuronâs activation, that neuron simply sums all of its weight values. Only those weight values that have a 1 in the input pattern are calculated. This is accomplished by using the following code:</p>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#00f;font-weight:700">for</span>(i<span style="color:#00f;font-weight:700">=</span><span style="color:#0000cd">0</span>; i <span style="color:#00f;font-weight:700">&lt;</span> x<span style="color:#00f;font-weight:700">.</span>length; i<span style="color:#00f;font-weight:700">++</span>){
    <span style="color:#00f;font-weight:700">if</span>(x[i]){
        a <span style="color:#00f;font-weight:700">+=</span> weightv[i];
    }
}
</pre>

          <h2>Step-by-step example</h2>

          <pre style="background:#fff;color:#000;border:0;"><span style="color:#00f;font-weight:700">Hopfield</span> hopfield <span style="color:#00f;font-weight:700">=</span> <span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">Hopfield</span>(<span style="color:#0000cd">4</span>);
hopfield<span style="color:#00f;font-weight:700">.</span>train(<span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[] {<span style="color:#0000cd">1</span>,<span style="color:#0000cd">1</span>,<span style="color:#0000cd">0</span>,<span style="color:#0000cd">0</span>});
hopfield<span style="color:#00f;font-weight:700">.</span>train(<span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[] {<span style="color:#0000cd">0</span>,<span style="color:#0000cd">0</span>,<span style="color:#0000cd">1</span>,<span style="color:#0000cd">1</span>});
   
<span style="color:#00f;font-weight:700">for</span>(<span style="color:#00f;font-weight:700">int</span> i <span style="color:#00f;font-weight:700">:</span> hopfield<span style="color:#00f;font-weight:700">.</span>recognize(<span style="color:#00f;font-weight:700">new</span> <span style="color:#00f;font-weight:700">int</span>[] {<span style="color:#0000cd">0</span>,<span style="color:#0000cd">0</span>,<span style="color:#0000cd">1</span>,<span style="color:#0000cd">0</span>})){
    <span style="color:#00f;font-weight:700">System</span><span style="color:#00f;font-weight:700">.</span>out<span style="color:#00f;font-weight:700">.</span>print(i);
}
</pre>

          <ul>
            <li>
              Training for {1, 1, 0, 0}:
              <ul>
                <li>bipolar vector (bi): {1, 1, -1, -1}</li>
                <li>
                  work matrix (work):
                  <img src="../images/pages/PAGE_Hopfield_Equation_6.gif" class="img-responsive">
                </li>
                <li>
                  weight matrix (matrix):
                  <img src="../images/pages/PAGE_Hopfield_Equation_6.gif" class="img-responsive">
                </li>
              </ul>
            </li>
            <li>
              Training for {1, 1, 0, 0}:
              <ul>
                <li>bipolar vector (bi): {1, 1, -1, -1}</li>
                <li>
                  work matrix (work):
                  <img src="../images/pages/PAGE_Hopfield_Equation_6.gif" class="img-responsive">
                </li>
                <li>
                  weight matrix (matrix):
                  <img src="../images/pages/PAGE_Hopfield_Equation_7.gif" class="img-responsive">
                </li>
              </ul>
            </li>
          </ul>

          <p>Result of recognition pattern {0, 0, 1, 0}: <strong>{0, 0, 1, 1}</strong>.</p>
        </div>
        </div>
        <div id='footer'>
          <div class='container'>
    <footer>
        <hr class='footer-divider' />

        <ul class='piped-links pull-right'>
            <li class='first piped-links-short'><a href='../resume.html'>About</a></li>
            <li class='first piped-links-long'><a href='../resume.html'>About Andrey Pudov</a></li>
            <li><a href='../contact.html'>Contact</a></li>
        </ul>

        <ul class='piped-links'>
            <p class='piped-links-long'>Copyright &#169; 2019 Andrey Pudov. All rights reserved.</p>
        </ul>

        <p class='piped-links-short'>&#169; 2019 Andrey Pudov. All rights reserved.</p>
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src='../libraries/jquery/jquery-1.11.3.min.js'></script>
    <!-- <script src='../libraries/jquery/jquery.validate.min.js'></script> -->

    <!-- <script src='../libraries/bootstrap/js/bootstrap.min.js'></script> -->

    <script src='../libraries/bootstrap/js/collapse.js' ></script>
    <script src='../libraries/bootstrap/js/dropdown.js' ></script>
    <script src='../libraries/bootstrap/js/transition.js' ></script>

    <!-- web page specific scripts declaration -->
    

    <!-- common on init functions -->
    <script src='../scripts/init.js'></script>
</div>
                 
        </div>
      </div>
    </body>
</html>
